#------------------------------------------------------------------------------
# _hlcm_get_all_link_libraries(<target> <output_var>)
# Recursively finds all shared objects required by the specified target.
#------------------------------------------------------------------------------

# NOTE: unfortunately, this doesn't seem to work for imported targets
#   generated by install(EXPORT ...) and import via find_package()

function(_hlcm_get_all_link_libraries)

  list(GET ARGN 0 target)
  list(GET ARGN 1 outvar)

  set(deps "")
  get_target_property(type ${target} TYPE)
  if (NOT type STREQUAL "INTERFACE_LIBRARY")
    get_target_property(llibs ${target} LINK_LIBRARIES)
    #message("llibs: ${llibs}")
    if (llibs)
      list(APPEND deps "${llibs}")
    endif()
  endif()
  get_target_property(ilibs ${target} INTERFACE_LINK_LIBRARIES)
  if (ilibs)
    #message("ilibs: ${ilibs}")
    list(APPEND deps "${ilibs}")
  endif()
  #message("Link libraries for target ${target}: ${deps}")
  #message("deps: ${deps}")
  if (deps)
    set(all_deps "")
    foreach(dep ${deps})
      string(REGEX MATCH "\\$<LINK_ONLY\\:([^\\)]*)>" m ${dep})
      #message("m: ${m}, CMAKE_MATCH_1: ${CMAKE_MATCH_1}")
      if (CMAKE_MATCH_1)
        set(dep ${CMAKE_MATCH_1})
      endif()
      # TODO: imported targets imported in a lower directory will not be available here!
      if (TARGET ${dep})
        #message("Dependency ${dep} is a target")
        get_property(type TARGET ${dep} PROPERTY TYPE)
        if (type STREQUAL "SHARED_LIBRARY")
          list(APPEND all_deps ${dep})
        endif()
        _hlcm_get_all_link_libraries(${dep} nested_deps)
        if (nested_deps)
          #message("nested deps of ${dep}: ${nested_deps}")
          list(APPEND all_deps "${nested_deps}")
        endif()
      else()
        #message("Dependency ${dep} is NOT a target (or it was imported from a different branch)")
      endif()
    endforeach()
  else()
    set(all_deps "")
  endif()

  list(REMOVE_DUPLICATES all_deps)
  set(${outvar} "${all_deps}" PARENT_SCOPE)

endfunction()

#------------------------------------------------------------------------------
# Determine the target's runtime output directory for a given configuration.
#
# Note: this is not currently being used. It was written for an earlier attempt
# at implementing copy_shared_libs(), before finding out that the
# $<TARGET_FILE_DIR:...> generator expression was what was needed.
#------------------------------------------------------------------------------

function(runtime_output_directory)

  list(GET ARGN 0 target)
  list(GET ARGN 1 config)
  list(GET ARGN 2 outvar)

  string(TOUPPER "${config}" cfg_uc)
  get_target_property(outdir ${target} "RUNTIME_OUTPUT_DIRECTORY_${cfg_uc}")
  if (NOT outdir)
    get_target_property(outdir ${target} "RUNTIME_OUTPUT_DIRECTORY")
    if (NOT outdir MATCHES "\\$\\<CONFIG\\>")
      set(outdir "${outdir}/${config}")
    endif()
  endif()

  set(${outvar} "${outdir}" PARENT_SCOPE)

endfunction()

set(syntax "\
ls_copy_shared_libs( <target>
  [CONFIGURATION <config>]
)

Will copy, post-build, the DLLs required by <target> to target's bin output directory.
The CONFIGURATION option can be used to limit this to a specific build configuration.
")

function(ls_copy_shared_libs)

  cmake_parse_arguments(args "" "CONFIGURATION" "" ${ARGN})

  list(GET args_UNPARSED_ARGUMENTS 0 target)
  set(config ${args_CONFIGURATION})

  if (NOT target)
    message(FATAL_ERROR "You must specify a target.\n${syntax}")
  endif()
  if  (NOT TARGET ${target})
    message(FATAL_ERROR "\"${target}\" does not designate a target (imported in other directory?)\n${syntax}")
  endif()

  _hlcm_get_all_link_libraries(${target} deps)
  #message("dep DLLs to copy: ${deps}")
  set(script "")
  foreach(dep ${deps})
    get_property(type TARGET ${dep} PROPERTY TYPE)
    if (type STREQUAL "SHARED_LIBRARY")
      set(script "${script}\nfile(COPY \"$<TARGET_FILE:${dep}>\" DESTINATION \"$<TARGET_FILE_DIR:${target}>\")")
    endif()
  endforeach()
  #message("script: ${script}")

  cmake_policy(SET CMP0070 NEW)
  if (config)
    set(cond_clause CONDITION $<CONFIG:${config}>)
  endif()
  file(GENERATE OUTPUT "copy_${target}_dlls_$<CONFIG>.cmake" CONTENT "${script}" ${cond_clause})

  if (args_CONFIGURATION)
    set(cmd "$<$<CONFIG:${config}>:${CMAKE_COMMAND}>")
  else()
    set(cmd "${CMAKE_COMMAND}")
  endif()
  add_custom_command(TARGET ${target} POST_BUILD
    COMMAND "${cmd}" ARGS -P copy_${target}_dlls_$<CONFIG>.cmake
  )

endfunction()

# NO LONGER IN USE
if (0)

function(copy_dll_and_dependencies)

  list(GET ARGN 0 target)
  list(GET ARGN 1 dll)

  _hlcm_get_all_link_libraries(${dll} deps)
  message("Dependencies of DLL ${dll} to copy: ${deps}")
  set(script "")
  foreach(dep ${deps})
    get_property(type TARGET ${dep} PROPERTY TYPE)
    if (type STREQUAL "SHARED_LIBRARY")
      set(script "${script}\nfile(COPY \"$<TARGET_FILE:${dep}>\" DESTINATION \"$<TARGET_FILE_DIR:${target}>\")")
    endif()
  endforeach()
  #message("script: ${script}")

  cmake_policy(SET CMP0070 NEW)
  file(GENERATE OUTPUT "copy_${target}_dlls_$<CONFIG>.cmake" CONTENT "${script}")

  add_custom_command(TARGET ${target} POST_BUILD COMMAND ${CMAKE_COMMAND} -P "copy_${target}_dlls_$<CONFIG>.cmake")

endfunction()

endif()